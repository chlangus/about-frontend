## 객체
- 객체를 만들때 '-' 이나 공백이 있을 시 ''로 감싸주어야 함
- 객체.property = '값' : 객체 property 추가 및 수정
- delete 객체.프로퍼티 : 객체 property 삭제   
- '프로퍼티' in 객체 : 객체 안에 변수가 존재하는지 유무, boolean값 리턴   
- 메소드이름: function(){ 메소드 내용 } : 객체 안에 존재하는 함수를 메소드 라고 부름
- for(let 변수 in 객체){ 변수 }
  > 반복문을 돌며 객체에 있는 프로퍼티를 하나씩 변수이름에 할당해줌
   
  > 숫자형 프로퍼티 네임이 있을경우 자동으로 오름차순 정렬을 시킴 
<br>

## 내장객체 Date
- let myDate = new Date(특정시간) : 특정시간(year, month, date, hour, min, sec)
  > new Date('2017-05-16');, new Date('2017-05-16T19:11:15');
  
  > 1000이라면 1000밀리초 = 1초   
- Month는 0부터 11까지    
- 요일은 0부터 6까지 일요일부터 토요일       
- myDate.getTime()은 몇밀리초인지 리턴   
<br>

## 배열
- 배열.length : 배열의 길이
- 배열[index] : '내용'배열의 index에 내용 추가 및 수정   
-  members.splice(1,1,'nice','hi'); : 배열.splice(삭제 시작할 인덱스, 몇개나 인덱스 삭제할지, 삭제한 요소 자리에 값 추가)    
- 배열.shift() : 배열의 첫 요소를 삭제 
- pop() : 배열의 마지막 요소를 삭제   
- unshift(값) : 배열의 첫 요소로 값 추가
- push(값) : 배열의 마지막 요소로 값 추가    
- indexOf('값') : 특정 값의 인덱스를 찾으려면 ,lastIndexOf('값') : 뒤에서부터      
- includes('값') : 포함되어있나 유무     
- reverse() : 배열 뒤집기   
- for...of : for(변수 of 배열){변수} 반복하면서 배열의 요소를 변수에 할당  
<br>

## 숫자의 표기
- 23e4 : 23에 e뒤의 수만큼 10의 거듭제곱
- 23e-4 : 23에 e뒤의 수만큼 10의 거듭제곱으로 나눔
- 숫자형.toFixed(n) : 한자릿수 더 뒤에서(n+1) 반올림하여 소수점 밑 n번째 자리수까지 나타냄
- 숫자형.toString(n) : n진수로 바꾸어줌
<br>

## Math객체
- Math.abs(-a) : 절댓값
- Math.max(a, b, c ...) : 최댓값
- Math.min(a, b, c ...) : 최솟값
- Math.pow(a, b) : 거듭제곱
- Math.sqrt(a, b) : 제곱근
- Math.round(a.xx) : 반올림
- Math.floor(a.xx) : 내림
- Math.ceil(a.xx) : 올림
- Math.random() : 0이상 1미만의 값 랜덤
<br>

## 문자열 함수
- 문자열.length : 문자열의 길이
- 문자열.indexOf('a') : 앞에서부터 문자의 index 탐색
- 문자열.lastIndexOf('a') : 뒤에서부터 문자의 index 탐색
- 문자열.trim() : 앞 뒤의 공백 제거
- 문자열.toUpperCase() : 대문자로 변환
- 문자열.toLowerCase() : 소문자로 변환
- 문자열.slice(start,end) : start부터 end 전까지 문자열 접근 
<br>

## 기본형과 참조형
- let x ={name:'codeit'} : 참조형(배열, 객체, 함수 등)
- let y = x : 주솟값이 복사되므로 y를 바꾸면 x값도 바뀜
- 배열을 .slice로 복사하면 값만 복사됨
- 사전형을 Object.assign({},사전형객체이름)으로 복사하면 값만 복사
- let x = 10 : 기본형(number, string, null, undefined, boolean, symbol)
- let y = x : 객체 안의 기본형을 집어넣을경우 기본형 취급하여 값만 복사
<br>

## null과 undefined
> null은 어떤 값이 의도적으로 비어있음을 표현합니다.

> undefined의 경우 값이 지정되지 않은것을 의미하지만 null은 어떤 객체도 가리키고 있지 않다는 것을 의미합니다.
<br>

### 함수 인자의 default값 중간에 두면 자연스레 뒤로 밀리게 됨
ex) function default(a, b=3, c) => default(a, c, b=3)
<br>

### 동일한 변수가 존재 할 시, 블록문에서 먼저 변수 탐색 후 없으면 전역변수 사용 
<br>

### 상수는 대문자와 밑줄로 구성   
ex)const MY_NUMBER = 13;   
<br>

## var과 let
이제 var을 쓰지 않는 이유
- 중복 선언이 가능하여 길고 복잡할 코드 작성 시 실수 할 가능성이 커지게 됩니다.   
- 변수의 구분이 함수에만 있기 때문에 지역 변수이더라도 의도치않게 전역변수의 역할을 하게 될 수도 있습니다.
  > 함수를 기준으로 적용되는 스코프는 함수 스코프, 코드 블록이 기준이라면 블록스코프라고 합니다.
- 변수의 선언을 뒤에 했더라도 위로 끌어올려가 사용이 가능해지게 됩니다.(호이스팅)
  > 선언과 동시에 값을 할당하더라도 선언문만 올려지기 때문에 값은 제 순서에 할당됩니다.
  > 이런 방식으로 동작하게 되면 코드의 흐름을 방해하기 때문에 주의해야 합니다.
<br>

## 배열과 문자열
배열과 문자열 둘 다 length 프로퍼티를 가지고 있고 대괄호 표기법으로 각 요소에 접근할 수 있다는 등의 공통점이 있습니다.   
하지만typeof 연산자로 자료형을 비교해보면 문자열은 string 배열은 object 자료형인것을 알 수 있습니다.    
가장 중요한 차이는 배열은 바뀔 수 있는 자료형인 반면 문자열은 바뀔 수 없는 자료형이라는 점입니다. 그래서 배열은 재할당이 가능하며 문자열은 재할당이 불가능합니다.   
<br>

## "=="와 "==="   
"=="는 동등 연산자로, 두 값을 비교할 때 형변환(type coercion)을 수행합니다. 즉, 비교하는 값의 데이터 타입이 다르더라도 자동으로 형변환을 수행한 후에 비교합니다. 이러한 형변환은 때로 예측하지 못한 결과를 초래할 수 있으므로, "=="를 사용할 때는 조심해야 합니다.    
"==="는 일치 연산자로, 두 값이 데이터 타입과 값이 모두 같은지 비교합니다.    
> 따라서 "==="를 사용하면 형변환 없이 정확한 값을 비교할 수 있습니다. 이러한 일치 연산자를 사용하는 것이 더 안전하고 예측 가능한 결과를 얻을 수 있습니다.
<br>

## 얕은 복사와 깊은 복사    
복사의 유형은 자료형에 따라 다르게 나타나게 됩니다. 자료형은 원시형과 원시형이 아닌 참조형으로 나눌수 있습니다.    
원시형 값을 변수에 할당하게 되면 값 자체가 변수에 할당이 됩니다. 그래서 변수를 참조값으로 하여 다른 변수에 할당하여도 원시타입은 값만 복사가 될 뿐 주소값을 공유하거나 하지 않습니다.   
참조형 값을 변수에 할당하게 되면 값을 가리키는 주소값이 변수에 할당이 됩니다. 그래서 그 변수를 다른 변수에 할당하게 되면 같은 주소값을 가리키게 되어 양쪽 어느곳에서 값을 바꾸어도 가리키는 주소는 같기 때문에 값이 같이 변하게 됩니다.   
> 즉 직접 값을 복사하는것은 깊은 복사, 값을 가리키고있는 메모리의 주소값을 복사하면 얕은 복사 라고 부를수 있습니다.   
<br>

