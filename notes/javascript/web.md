## web
- World Wide Web
- 가상의 연결망들이 무수히 연결되어있는 것
- 웹페이지에 있는 텍스트들은 하이퍼 텍스트로 다른것들에 대한 참조를 갖고있음
- 점점 웹이 발전하면서 하이퍼 텍스트 뿐만 아니라 이미지나 동영상등 여러가지 종류의 매체를 다룰 수 있게 됨
<br>

## URL(Uniform Resource Locator)
- 웹에 존재하는 특정 데이터를 가리키는 문자열
- 문자열은 Host, Path, Query로 이루어짐
  - Host : 전세계 서버 중 하나의 서버를 특정
  - Path : 서버에 있는 데이터 중 원하는 데이터를 특정
  - Query : 데이터에 관한 세부적인 요구사항
- url을 입력하고 엔터를 치게 되면 일어나는 일
  1. 전세계의 서버중 어느 서버와 통신을 해야하는지를 찾게되는데 이때 적힌 Host이름을 도메인 네임이라고 합니다. 어려운 ip주소 대신해 외우기 쉬운 문자열로 나타낸 것입니다. 도메인 네임과 실제의 ip주소를 특정하기 위해 Domain Name Resolution이라고 하는 작업을 수행 해야 함
  2. 어떤 서버와 통신해야하는지 식별한 후에 해당 서버로 리퀘스트를 보냅니다. 이때 url에서 path와 query 부분을 담아 보냄
  3. 서버는 path 이후의 부분을 보고 그것이 의미하는 데이터를 찾고 결과를 리스폰스에 담아 보냄
  4. 리스폰스의 내용을 갖고 사용자에게 보여줌
- 웹 브라우저로 특정 페이지에 접속할때 보통 한번 이상의 리퀘스트쌍이 오고감 
<br>

## http
- http는 hypertext transfer protocol로 다른 텍스트에 대한 참조를 갖고 있는 텍스트를 나타냄
- URL의 앞부분은 스킴이라하며 이 부분에는 프로토콜(통신규약)이 들어감
- htpps는 secure이 붙어 안전규약이 추가된 http 
<br>

## json
- 자바스크립트의 문법이 일정부분 호환되는 데이터 포맷  
- json 타입의 경우 프로퍼티의 이름에 큰따옴표(")를 붙여줘야며 문자열일 경우 큰 따옴표를로 감싸줘야 함
  > {"name":"Gil Dong"}
- undefined, NaN, Infinity등은 json에서 사용할 수 없음
- 주석을 추가할 수 없음
- `리스폰스.text()` : 리스폰스로 받은 데이터를 추출 
- `JSON.parse(json객체)` : 추출된 데이터를 자바스크립트 객체로 바꿈 
- `리스폰스.json()` : 리스폰스로 받은 데이터를 추출 후 자바스크립트 객체로 바꿈 
<br>

## request
request에는 `Head`와 `Body`가 존재 하며 head에는 메서드, body에는 전달할 데이터가 들어감 
- `JSON.stringify(javascript객체)` : javascript 객체를 json객체에 보내기 위한 문법 
- `GET` : 기존 데이터를 조회하는 리퀘스트
- `POST` : 새 데이터를 추가하는 리퀘스트
- `PUT` : 기존 데이터를 수정하는 리퀘스트
- `DELETE` : 기존 데이터를 삭제하는 리퀘스트
<br>

## REST API
- REST architecture에 부합하는 API
<br>

## response
response에 `Head`와 `Body`가 존재, Head는 Response에 대한 부가 정보가, Body에는 실제 데이터가 담김 
- Head에는 상태 코드가 담겨있음
<br>

## Status Code
- 각각의 상태 코드에는 대응되는 상태 메시지가 존재
- 100번대: 서버가 클라이언트에게 정보성 응답을 줄 때 사용
- 200번대: 클라이언트의 리퀘스트가 성공 처리되었음을 의미
- 300번대: 클라이언트의 리퀘스트가 아직 처리되지 않았고, 리퀘스트의 처리를 원하면 클라이언트 측의 추가적인 작업이 필요함
- 400번대: 리퀘스트를 보내는 클라이언트 쪽에 문제가 있음을 의미
- 500번대: 서버 쪽의 문제로 인해 리퀘스트를 정상적으로 처리할 수 없음을 의미
<br>

## fetch 함수
- fetch함수는 Promise 객체를 리턴
- 이 객체의 then 메소드로, '응답이 왔을 때 실행할 콜백'을 등록할 수 있다.
- 등록된 콜백들은 then메소드로 등록한 순서대로 실행되고, 이때 이전 콜백의 리턴값을 이후 콜백이 넘겨받아서 사용할 수 있음
- 바로 리스폰스를 사용할 수 없고 이 응답에 대한 처리를 따로 해주어야 데이터를 선별하여 사용할 수 있음
<br>

## 동기와 비동기
- 특정 작업을 시작하고 완벽히 완료하기 전에 실행 흐름이 바로 다음 코드로 넘어가고 나중에 실행되는 것을 `비동기 실행` 이라고 함
- 한번 시작한 작업은 다 처리하고 나서야 다음 코드로 넘어가는 방식의 실행은 `동기 실행`이라고 함
- `setTimeout(()=>{}, 1000)`함수는 두번째 인자로 주어진 밀리초만큼 기다렸다가 콜백함수를 실행
- `setInterval(()=>{}, 1000)`함수는 두번째 인자로 주어진 밀리초 간격으로 계속 콜백함수 실행
<br>

## Promise
- 어떤 작업의 상태를 보이는 객체
- pending, funlfilled, rejected 상태를 가짐 
- 작업의 결과를 함께 가짐
- then() 메서드를 가짐, Promise객체가 fulfilled 상태가 되었을때 실행할 콜백함수를 등록
- then메서드의 return값이 프로미스 객체라면 then메서드의 상태는 then메서드의 return값을 따라감
- then메서드의 return값이 프로미스 객체가 아니라면 then메서드의 상태는 fulfilled상태가 됨
- .text(), .json메서드도 Promise객체를 리턴
- 프로미스 체이닝은 비동기작업을 순서대로 실행하기 위해 사용, 비동기 작업이 많더라도 깔끔하게 처리 가능 
- then 메서드의 두번째 인자는 작업 상태가 rejected 됐을때의 결과값 반
<br>


