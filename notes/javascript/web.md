## web
- World Wide Web
- 가상의 연결망들이 무수히 연결되어있는 것
- 웹페이지에 있는 텍스트들은 하이퍼 텍스트로 다른것들에 대한 참조를 갖고있음
- 점점 웹이 발전하면서 하이퍼 텍스트 뿐만 아니라 이미지나 동영상등 여러가지 종류의 매체를 다룰 수 있게 됨
<br>

## URL(Uniform Resource Locator)
- 웹에 존재하는 특정 데이터를 가리키는 문자열
- 문자열은 Host, Path, Query로 이루어짐
  - Host : 전세계 서버 중 하나의 서버를 특정
  - Path : 서버에 있는 데이터 중 원하는 데이터를 특정
  - Query : 데이터에 관한 세부적인 요구사항
- url을 입력하고 엔터를 치게 되면 일어나는 일
  1. 전세계의 서버중 어느 서버와 통신을 해야하는지를 찾게되는데 이때 적힌 Host이름을 도메인 네임이라고 합니다. 어려운 ip주소 대신해 외우기 쉬운 문자열로 나타낸 것입니다. 도메인 네임과 실제의 ip주소를 특정하기 위해 Domain Name Resolution이라고 하는 작업을 수행 해야 함
  2. 어떤 서버와 통신해야하는지 식별한 후에 해당 서버로 리퀘스트를 보냅니다. 이때 url에서 path와 query 부분을 담아 보냄
  3. 서버는 path 이후의 부분을 보고 그것이 의미하는 데이터를 찾고 결과를 리스폰스에 담아 보냄
  4. 리스폰스의 내용을 갖고 사용자에게 보여줌
- 웹 브라우저로 특정 페이지에 접속할때 보통 한번 이상의 리퀘스트쌍이 오고감 
<br>

## http
- http는 hypertext transfer protocol로 다른 텍스트에 대한 참조를 갖고 있는 텍스트를 나타냄
- URL의 앞부분은 스킴이라하며 이 부분에는 프로토콜(통신규약)이 들어감
- htpps는 secure이 붙어 안전규약이 추가된 http 
<br>

## json
- 자바스크립트의 문법이 일정부분 호환되는 데이터 포맷  
- json 타입의 경우 프로퍼티의 이름에 큰따옴표(")를 붙여줘야며 문자열일 경우 큰 따옴표를로 감싸줘야 함
  > {"name":"Gil Dong"}
- undefined, NaN, Infinity등은 json에서 사용할 수 없음
- 주석을 추가할 수 없음
- `리스폰스.text()` : 리스폰스로 받은 데이터를 추출 
- `JSON.parse(json객체)` : 추출된 데이터를 자바스크립트 객체로 바꿈 
- `리스폰스.json()` : 리스폰스로 받은 데이터를 추출 후 자바스크립트 객체로 바꿈 
<br>

## request
request에는 `Head`와 `Body`가 존재 하며 head에는 메서드, body에는 전달할 데이터가 들어감 
- `JSON.stringify(javascript객체)` : javascript 객체를 json객체에 보내기 위한 문법 
- `GET` : 기존 데이터를 조회하는 리퀘스트
- `POST` : 새 데이터를 추가하는 리퀘스트
- `PUT` : 기존 데이터를 수정하는 리퀘스트
- `DELETE` : 기존 데이터를 삭제하는 리퀘스트
<br>

## REST API
- REST architecture에 부합하는 API
<br>

## response
response에 `Head`와 `Body`가 존재, Head는 Response에 대한 부가 정보가, Body에는 실제 데이터가 담김 
- Head에는 상태 코드가 담겨있음
<br>

## Status Code
- 각각의 상태 코드에는 대응되는 상태 메시지가 존재
- 100번대: 서버가 클라이언트에게 정보성 응답을 줄 때 사용
- 200번대: 클라이언트의 리퀘스트가 성공 처리되었음을 의미
- 300번대: 클라이언트의 리퀘스트가 아직 처리되지 않았고, 리퀘스트의 처리를 원하면 클라이언트 측의 추가적인 작업이 필요함
- 400번대: 리퀘스트를 보내는 클라이언트 쪽에 문제가 있음을 의미
- 500번대: 서버 쪽의 문제로 인해 리퀘스트를 정상적으로 처리할 수 없음을 의미
<br>

## fetch 함수
- fetch함수는 Ajax 통신을 하는 함수이며, Promise 객체를 리턴
- 이 객체의 then 메소드로, '응답이 왔을 때 실행할 콜백'을 등록할 수 있다.
- 등록된 콜백들은 then메소드로 등록한 순서대로 실행되고, 이때 이전 콜백의 리턴값을 이후 콜백이 넘겨받아서 사용할 수 있음
- 바로 리스폰스를 사용할 수 없고 이 응답에 대한 처리를 따로 해주어야 데이터를 선별하여 사용할 수 있음
<br>

## 동기와 비동기
- 특정 작업을 시작하고 완벽히 완료하기 전에 실행 흐름이 바로 다음 코드로 넘어가고 나중에 실행되는 것을 `비동기 실행` 이라고 함
- 한번 시작한 작업은 다 처리하고 나서야 다음 코드로 넘어가는 방식의 실행은 `동기 실행`이라고 함
- `setTimeout(()=>{}, 1000)`함수는 두번째 인자로 주어진 밀리초만큼 기다렸다가 콜백함수를 실행
- `setInterval(()=>{}, 1000)`함수는 두번째 인자로 주어진 밀리초 간격으로 계속 콜백함수 실행
<br>

## Promise
- 어떤 작업의 상태를 보이는 객체
- pending, funlfilled, rejected 상태를 가짐 
- 작업의 결과를 함께 가짐
- then() 메서드를 가짐, Promise객체가 fulfilled 상태가 되었을때 실행할 콜백함수를 등록
- then메서드의 return값이 프로미스 객체라면 then메서드의 상태는 then메서드의 return값을 따라감
- then메서드의 return값이 프로미스 객체가 아니라면 then메서드의 상태는 fulfilled상태가 됨
- .text(), .json메서드도 Promise객체를 리턴
- 프로미스 체이닝은 비동기작업을 순서대로 실행하기 위해 사용, 비동기 작업이 많더라도 깔끔하게 처리 가능 
- then 메서드의 두번째 인자는 작업 상태가 rejected 됐을때의 결과값 반환
- catch 메서드는 then메서드의 두번째 파라미터를 다루는 메서드
- 아무런 콜백도 실행되지 않을때 이전 Promise 객체와 동일한 상태와 결과를 갖게 됨
- 일반적으로 catch 메서드는 마지막에 쓰지만 중간에 사용되어 결과를 뒤에 넘겨줄 수 있다면 중간에도 사용된다.
- finally 메서드는 무조건 실행됨
- 비동기 실행 함수를 Promise 객체로 감싸서 그 Promise 객체를 리턴하는 형식으로 만드는 작업을 Promisify라고 한다
- Promisify를 하는 이유는 비동기 실행 함수의 콜백이 리턴하는 값을 Promise Chain에서 사용하고 싶을 때
- `new Promise((resolve, reject)=> {resolve(data)})` : 프로미스 객체 생성 resolve는 fulfilled시 반환값, reject는 reject시 반환값
- 콜백이 딱 한번만 실행되는 함수인 경우에만 Promisify를 해야 한다. Promise객체의 상태및 결과는 고정되면 바뀌지 않음
- all 메서드로 모든 Promise 객체를 가져올 수 있음
- race 메서드는 가장 빨리 값과 상태가 결정되는 Promise객체를 선택하는 메서드 
<br>

## axios
- 모든 리퀘스트, 리스폰스에 대한 공통 설정 및 공통된 전처리 함수 삽입 가능
- serialization, deserialization를 자동으로 수행
- 특정 리퀘스트에 대해 아임아웃 설정 가능
- 업로드 시 진행 상태 정보 얻을 수 있음
- 리퀘스트 취소 기능 존재 
<br>

## async/await
- async는 함수 안에 비동기 적으로 실행되는 부분이 있다는것을 의미 
- await는 Promise 객체를 반환하는 코드 앞에 붙임, 이 코드를 만나면 함수 바깥으로 실행 흐름이 넘어가며, 함수안은 await 붙은 코드가 실행될때까지 기다린 후에 다음 코드 라인 실행
- await는 async가 붙어있는 함수 안에서만 사용 가능
- 기존 Promise객체를 사용하는 코드를 개발자가 더 편하게 작성할 수 있도록 하고 코드의 가독성을 높이기 위해서 도입됨
- async 함수는 항상 Promise 객체를 리턴
- async 함수 안에서 async함수 앞에 await를 붙여 사용 가능 
